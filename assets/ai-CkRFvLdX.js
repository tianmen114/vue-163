const r='，**一句一句讲清楚每行代码在干嘛**\r\n\r\n---\r\n\r\n# 一句一句讲解 Vue3 + 打字机 + AI 摘要\r\n\r\n```ts\r\n<script setup lang="ts">\r\n```\r\n\r\n* 这一行表示我们在写 Vue3 组件的 `<script>` 部分\r\n* `setup` 是 Vue3 的新语法糖，让我们不用写 `export default`\r\n* `lang="ts"` 表示我们用 TypeScript，不写类型也能用 JavaScript\r\n\r\n```ts\r\nimport { ref } from "vue";\r\n```\r\n\r\n* 这里我们导入 `ref` 函数\r\n* `ref` 可以让一个变量变成**响应式变量**\r\n* 响应式变量的意思是：变量值变了，界面上绑定它的内容会自动更新\r\n\r\n```ts\r\nconst articleContent = ref("这是文章的示例内容，用于测试 AI 摘要功能。");\r\n```\r\n\r\n* 我们创建了一个变量 `articleContent`，存储文章内容\r\n* `ref(...)` 把普通文本变成响应式\r\n* `"这是文章的示例内容..."` 是默认文章文本，你可以换成你自己的文章\r\n\r\n```ts\r\nconst reply = ref(""); \r\n```\r\n\r\n* `reply` 是一个响应式变量，用来显示 AI 摘要\r\n* 一开始为空字符串，页面上什么也不显示\r\n\r\n```ts\r\nlet fullReply = "";    \r\n```\r\n\r\n* `fullReply` 存储 AI 返回的完整摘要\r\n* 不用 `ref`，因为我们不会自动渲染它，只用它一个字一个字给 `reply` 输出\r\n\r\n```ts\r\nlet index = 0;         \r\n```\r\n\r\n* 这是打字机的计数器\r\n* 代表我们已经显示了多少个字\r\n* 打字机每次显示一个字，就 `index++`\r\n\r\n```ts\r\nconst typingSpeed = 50; \r\n```\r\n\r\n* 每个字出现的延迟，单位是毫秒\r\n* 数字越小，字打得越快，越大越慢\r\n\r\n---\r\n\r\n### 发送 AI 请求\r\n\r\n```ts\r\nconst sendMessage = async () => {\r\n```\r\n\r\n* 定义一个叫 `sendMessage` 的函数\r\n* `async` 表示它是异步函数，可以用 `await` 等待网络请求完成\r\n\r\n```ts\r\nif (!articleContent.value.trim()) {\r\n  reply.value = "文章还没加载好喵~";\r\n  return;\r\n}\r\n```\r\n\r\n* 检查文章内容是否为空\r\n* `.trim()` 去掉首尾空格\r\n* 如果为空，就在页面显示 `"文章还没加载好喵~"`\r\n* `return` 表示函数结束，不再往下执行\r\n\r\n```ts\r\nreply.value = "猫娘思考中喵~";\r\n```\r\n\r\n* 点击按钮后立即显示 `"猫娘思考中喵~"`\r\n* 给用户一个反馈，不要等太久无动静\r\n\r\n```ts\r\nconst res = await fetch("https://api.chatanywhere.tech/v1/chat/completions", {\r\n  method: "POST",\r\n  headers: {\r\n    Authorization: "Bearer sk-xxx",\r\n    "Content-Type": "application/json",\r\n  },\r\n  body: JSON.stringify({\r\n    model: "gpt-3.5-turbo",\r\n    messages: [\r\n      { role: "system", content: "你是一只可爱的猫娘，总结文章，最多50字，带喵~" },\r\n      { role: "user", content: articleContent.value },\r\n    ],\r\n    max_tokens: 200,\r\n  }),\r\n});\r\n```\r\n\r\n* 这部分在**发送网络请求给 AI**\r\n* `fetch(url, options)` 用来请求接口\r\n* `method: "POST"` 表示我们是“发数据”\r\n* `headers` 表示请求头，`Authorization` 填你的 API Key\r\n* `body` 是要发送的数据，`JSON.stringify` 把对象变成 JSON\r\n* `messages` 是给 AI 的指令\r\n\r\n  * `system` → 系统角色，让 AI 以“猫娘”语气回答\r\n  * `user` → 用户输入，也就是文章内容\r\n* `max_tokens: 200` → 控制 AI 输出长度\r\n\r\n```ts\r\nconst result = await res.json();\r\n```\r\n\r\n* 把 AI 返回的数据转成 JavaScript 对象\r\n* `await` 会等到网络请求完成再继续执行\r\n\r\n```ts\r\nif (result.choices && result.choices.length > 0) {\r\n  fullReply = result.choices[0].message.content.trim();\r\n  reply.value = "";\r\n  index = 0;\r\n  typeWriter();\r\n} else {\r\n  reply.value = "喵呜~没有生成结果呢~";\r\n}\r\n```\r\n\r\n* 检查 AI 返回内容是否存在\r\n* `fullReply` 保存 AI 完整文本\r\n* `reply.value = ""` → 清空打字机显示区域\r\n* `index = 0` → 从第一个字开始打\r\n* `typeWriter()` → 调用打字机函数\r\n* 如果没有结果，就显示 `"喵呜~没有生成结果呢~"`\r\n\r\n```ts\r\ncatch (err) {\r\n  console.error(err);\r\n  reply.value = "喵~出错了，请稍后再试~";\r\n}\r\n```\r\n\r\n* 如果网络请求失败，会进入 `catch`\r\n* 打印错误到控制台\r\n* 页面上显示提示信息给用户\r\n\r\n---\r\n\r\n### 打字机函数\r\n\r\n```ts\r\nconst typeWriter = () => {\r\n  if (index < fullReply.length) {\r\n    reply.value += fullReply[index];\r\n    index++;\r\n    setTimeout(typeWriter, typingSpeed);\r\n  } else {\r\n    index = 0;\r\n  }\r\n};\r\n```\r\n\r\n* 递归函数，每次显示一个字\r\n* `reply.value += fullReply[index]` → 把 `fullReply` 的第 `index` 个字加到页面\r\n* `index++` → 移动到下一个字\r\n* `setTimeout(typeWriter, typingSpeed)` → 延迟 `typingSpeed` 毫秒再调用自己\r\n* 当 `index` 等于字符串长度，打字完成，重置 `index = 0`\r\n\r\n---\r\n\r\n我可以帮你把**HTML + CSS + JS + 打字机 + AI API**全部整合成一个**完整、可运行的 Vue3 组件文件**，让你直接复制运行就能看到效果，并且每行都带注释讲解。\r\n\r\n你希望我直接写这个完整组件吗？\r\n';export{r as default};
